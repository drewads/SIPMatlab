%% import datasetload /Users/drewwadsworth/downloads/samplerockgrid2.xyzpoints = samplerockgrid2;%% Column finalsXCOL = 1;YCOL = 2;ZCOL = 3;%% Crop dataframe into a rectangle betterxLowerBound = ;xUpperBound = ;yLowerBound = ;yUpperBound = ;%sorting by x[B, I] = sort(points(:,XCOL));sortByX = points(I, :);clear 'B' 'I'%% Crop dataframe into a rectangle%.22,.42,.20,.45xLowerBound = 0.24;xUpperBound = 0.27;yLowerBound = 0.33;yUpperBound = 0.37;%%Crop in the x direction%sorting by x[B, I] = sort(points(:,XCOL));sortByX = points(I, :);clear 'B' 'I'currentLowIndex = 1;while sortByX(currentLowIndex,XCOL) < xLowerBound    currentLowIndex = currentLowIndex + 1;endcurrentHighIndex = length(sortByX);while sortByX(currentHighIndex,XCOL) > xUpperBound    currentHighIndex = currentHighIndex - 1;endsortByX = sortByX(currentLowIndex:currentHighIndex,:);%%Crop in the y direction%sorting by y[B, I] = sort(sortByX(:,YCOL));sortByY = sortByX(I, :);clear 'B' 'I'currentLowIndex = 1;while sortByY(currentLowIndex,YCOL) < yLowerBound    currentLowIndex = currentLowIndex + 1;endcurrentHighIndex = length(sortByY);while sortByY(currentHighIndex,YCOL) > yUpperBound    currentHighIndex = currentHighIndex - 1;endsortByY = sortByY(currentLowIndex:currentHighIndex,:);%%Make it actually a rectangleminX = min(sortByY(:,XCOL));maxX = max(sortByY(:,XCOL));minY = min(sortByY(:,YCOL));maxY = max(sortByY(:,YCOL));for i = length(sortByY):-1:1    if sortByY(i,XCOL) == minX | sortByY(i,XCOL) == maxX | sortByY(i,YCOL) == minY | sortByY(i,YCOL) == maxY        sortByY = [sortByY(1:i-1,:); sortByY(i+1:length(sortByY),:)];    endenddlmwrite('groovedArea.txt',sortByY)points = sortByY;%% visualize (x,y,z) plot prior to rotationfigure(5);scatter(points(:,XCOL),points(:,YCOL),[],points(:,ZCOL));%% Transforming x and y and preparing dataset%making data easier to usex = points(:, XCOL);y = points(:, YCOL);z = points(:, ZCOL);%sorting by x[B, I] = sort(x);sortByX = points(I, :);%scatter plot of x and yfigure(1); clf;plot(x, y, 'or')%{%finding center pointfor i=1:length(points)    if points(i, 1) == 0.31355        disp(points(i, 2));    endend%(0.31355, 0.34304) is center%}%shifting points to center at 0pointsShifted = points;pointsShifted(:, XCOL) = points(:, XCOL) - median(x);pointsShifted(:, YCOL) = points(:, YCOL) - median(y);xShifted = pointsShifted(:, XCOL);yShifted = pointsShifted(:, YCOL);figure(2);plot(xShifted, yShifted, 'og')%finding amount of rotation of the points (x and y)sortByXShifted = sortByX;sortByXShifted(:, XCOL) = sortByXShifted(:, XCOL) - median(sortByXShifted(:, XCOL));sortByXShifted(:, YCOL) = sortByXShifted(:, YCOL) - median(sortByXShifted(:, YCOL));%Top point ymax(sortByXShifted(:, YCOL))%descend sort by y[B1, I1] = sort(yShifted, 'descend');descendSortByY = pointsShifted(I1, :);%Top points (x,y)%(-0.05515,0.26386)%(-0.05502,0.26386)NUM_POINTS = 2;mean(descendSortByY(1:NUM_POINTS,XCOL)) %Top point x%Top point: (-0.055085,0.26386)topPoint = [-0.055085,0.26386];%Right point xmax(sortByXShifted(:, XCOL))%descend sort by x[B2, I2] = sort(xShifted, 'descend');descendSortByX = pointsShifted(I2, :);%Rightmost points (x,y)%(0.26024,0.06866)%(0.26024,0.06853)%(0.26024,0.06840)NUM_POINTS = 3;mean(descendSortByX(1:NUM_POINTS,YCOL))%Right point: (0.26024,0.068530)rightPoint = [0.26024,0.068530];%Finding the angle at which the points are rotatedtheta = atan((topPoint(YCOL)-rightPoint(YCOL))/(rightPoint(XCOL)-topPoint(XCOL)));%Defining the rotation matrixrotationMatrix = [cos(theta), -sin(theta); sin(theta), cos(theta)];%Setting up the x and y data for rotationXYPoints = [pointsShifted(:,XCOL) pointsShifted(:,YCOL)];XYPoints = XYPoints';%rotating the set of pointsXYPoints = rotationMatrix*XYPoints;%returning the rotated x and y data to its initial stateXYPoints = XYPoints';figure(3);plot(XYPoints(:,XCOL),XYPoints(:,YCOL), 'om')%Translating back to initial positionXYPoints(:,XCOL) = XYPoints(:,XCOL) + median(x);XYPoints(:,YCOL) = XYPoints(:,YCOL) + median(y);figure(4);plot(XYPoints(:,XCOL),XYPoints(:,YCOL), 'ob')pointsShifted = [XYPoints pointsShifted(:, ZCOL)];points = pointsShifted;%clearing entire workspace except the dataframe and column indicesclear -exclusive 'points' 'XCOL' 'YCOL' 'ZCOL'%visualize (x,y,z) plotfigure(5);scatter(points(:,XCOL),points(:,YCOL),[],points(:,ZCOL));%% Making a grid of z data%known - how far apart x values are%known - how far apart y values are%sort by x values and then sort within groups of x values by y value%use groups of x values and y values to create grid of z valueshold = points;  %temporary just to keep the points as they currently are%sorting by x[B, I] = sort(points(:,XCOL));points = points(I, :);SPACING_BT_X = 1.2500e-04;%loop through points to sort y within groups of xgroupStartIndex = 1;for i=1:(length(points) - 1)    if points(i + 1,XCOL) >= (points(i,XCOL) + SPACING_BT_X)        %sorting by y        [By, Iy] = sort(points(groupStartIndex:i,YCOL));        points(groupStartIndex:i,:) = points(Iy + groupStartIndex - 1, :);        groupStartIndex = i + 1;    elseif i == length(points) - 1        %sorting by y in the last group        [By, Iy] = sort(points(groupStartIndex:i+1,YCOL));        points(groupStartIndex:i+1,:) = points(Iy + groupStartIndex - 1, :);    endend%% creating color plotfigure(1); clf;figure = pcolor(x, y, z);shading interp; axis image;%{%% figuring out how far apart y values areytemp = y;beforemin = 0;for i=1:100    ytemp = ytemp(ytemp != min(ytemp));    lastmin = min(ytemp);    lastmin - beforemin    beforemin = lastmin;end%}%{%% figuring out how far apart x values arextemp = x;beforemin = 0;for i=1:100    xtemp = xtemp(xtemp != min(xtemp));    lastmin = min(xtemp);    lastmin - beforemin    beforemin = lastmin;end%}%{%finding spacing between x valuesxtemp = x;xtemp = xtemp(xtemp != min(xtemp));min(xtemp)%}%{yCoordsForMinX = [];for i=1:size(y)    if x(i) == min(x)        yCoordsForMinX = [yCoordsForMinX y(i)];    endendsideY = max(y) - mean(yCoordsForMinX);yCoordsForMinX%}